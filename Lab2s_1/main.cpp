#include "myRect.cpp"
#include "myString.h"
#include "Bochka.cpp"
#include <iostream>
#include<string>
using namespace std;


Rect BoundingRect(Rect r1, Rect r2){
	int maxL = (r1.GetAll("m_left") < r2.GetAll("m_left")) ? r1.GetAll("m_left") : r2.GetAll("m_left");
	int maxR = (r1.GetAll("m_right") > r2.GetAll("m_right")) ? r1.GetAll("m_right") : r2.GetAll("m_right");
	int maxT = (r1.GetAll("m_top") > r2.GetAll("m_top")) ? r1.GetAll("m_top") : r2.GetAll("m_top");
	int maxB = (r1.GetAll("m_bottom") < r2.GetAll("m_bottom")) ? r1.GetAll("m_bottom") : r2.GetAll("m_bottom");
	Rect r3(maxL, maxR, maxT, maxB);
	return r3;
}

Rect BoundingRect2(Rect & r1, Rect & r2) {
	int maxL = (r1.GetAll("m_left") < r2.GetAll("m_left")) ? r1.GetAll("m_left") : r2.GetAll("m_left");
	int maxR = (r1.GetAll("m_right") > r2.GetAll("m_right")) ? r1.GetAll("m_right") : r2.GetAll("m_right");
	int maxT = (r1.GetAll("m_top") > r2.GetAll("m_top")) ? r1.GetAll("m_top") : r2.GetAll("m_top");
	int maxB = (r1.GetAll("m_bottom") < r2.GetAll("m_bottom")) ? r1.GetAll("m_bottom") : r2.GetAll("m_bottom");
	Rect r3(maxL, maxR, maxT, maxB);
	return r3;
}


void numz(int n) {
	cout << "--------------------------------" << endl;
	cout << "Задание " << n << ":" << endl;
}

int main()
{
	setlocale(LC_ALL, "ru");
	cout << "В заданиях 1-5, использующих класс Rect, прямоугольник задается четыремя числами, \
           \nкоторые в свою очередь задают две точки с координатами х и у.\
           \nПервые вводимые два числа это х1 и х2, вторые - у1 и у2 соответственно.\
           \nВ заданиях 1-3 и 5 не учитывается правильность координат создаваемого прямоугольника\
           \nдля простоты проверки заданий. В задании 4 правильность координат учитывается.\n " << endl;
	/*Для того, чтобы выводились только значения прямоугольника и др задания,
	  закомментируйте все фразы "Вызвался...". Эти фразы нужны для проверки
	  или ответов на определенные задания. */
	{

		numz(1);
		//Задание 1.Объявление класса. Создание экземпляра класса.
		//Вызов методов класса.
		//Откройте закладку Class View - (здесь Вы увидите имена методов и
		//данных - классов Rect и MyString)
		//Обратите внимание на пиктограммы слева от имен членов класса - они
		//обозначают спецификатор доступа к каждому члену класса.

		//Какой конструктор вызывается при создании экземпляра класса?
		{
			Rect rect; //Конструктор с параметрами по умолчанию
		}

		//1a. Объявите и определите конструктор с параметрами для
		//инициализации переменных класса. Создайте экземляры класса Rect
		//с помощью конструктора с параметрами. Если компилятор выдает
		//ошибку в предыдущем фрагменте, подумайте - чего ему не
		//хватает? Добейтесь отсутствия ошибок.
		//Выполняя задание с самого начала по шагам, определите:
		//в какой момент происходит вызов конструктора(какого?)?

		//Подсказка: учтите, что пользователь Вашего класса может указывать
		//в качестве параметров любые значения!
		Rect test1(12, 13, 14, 15);
		test1.print();


		//1б. При конструировании объекта посредством конструктора без параметров
		//предусмотрите инициализацию переменных класса, например, нулем

		Rect test2;
		test2.print();


		//1в. Объявите, определите и вызовите метод класса InflateRect(),
		//который увеличивает размеры прямоугольника на заданные приращения
		//(раздвигая стороны от центра - каждую сторону на свое значение).
		//Подсказка: объявить и определить методы можно не только "вручную",
		//но и с помощью Wizard-a Class View. Для этого: откройте закладку
		//ClassView окна проекта, сделайте активным класс Rect и нажмите
		//правую кнопку мыши - в появившемся контекстном меню выберите
		//Add/Add Member Function... С помощью появившейся диалоговой панели
		//"дайте указания" Wizard-у как объявить и определить метод.
		test1.InflateRect(1, 1, 1, 1);
		test1.print();



	}
	{
		numz(2);

		//Задание 2.Перегрузка конструкторов и методов класса.
		//Конструктор копирования.

		//2а.Объявите и определите конструктор копирования в классе Rect.
		//Выполняя задание по шагам, определите, какой
		//конструктор вызывается при создании r1,r2,r3 и r4?
		//Чему равны переменные созданных объектов?
		Rect r1; // вызывается конструктор без параметров (вывод - 0,0,0,0)
		Rect r2(1, 2, 3, 4); //вызывается конструктор с параметрами (вывод - 1,2,3,4)
		Rect r3 = r1; // вызывается конструктор без параметров
		Rect r4(r2); // вызывается конструктор без параметров (вывод - 0,0,0,0)



		//2б. Объявите и определите в классе Rect метод InflateRect(),
		  //который принимает два аргумента, по умолчанию равных 1, и
		  //раздвигает стороны прямоугольника на на заданные приращения.
		  //Для каких объектов вызывается функция InflateRect()?
		r1.InflateRect(1, 1);// вывод - 1, 1, 1, 1
		r1.print();
		r2.InflateRect(2, 2); // вывод - 3, 4, 5, 6
		r2.print();
		cout << endl;
		//Какая из функций InflateRect() вызывается в каждом из трех случаев?
		r3.InflateRect(2, 2, 2, 2); //первая
		r3.print();
		r3.InflateRect(3, 3); // вторая
		r3.print();
		r3.InflateRect(5); // вторая
		r3.print();
		r3.InflateRect(); // вторая
		r3.print();



	}
		//Задание 3.Спецификаторы доступа. Инкапсуляция.
			numz(3);
		{

		Rect r;
		//Раскомментируйте следующую строку. Объясните ошибку
		//компилятора

		//int tmp = r.m_left; //переменная запривачена ключевым словом private



		//Введите в класс Rect метод void SetAll(...),
		//который присваивают переменным класса передаваемые
		//значения. Вызовите созданный метод, проверьте корректность.
		r.SetALL(4, 3, 2, 1);
		r.print();

		//Введите в класс Rect парный метод GetAll(...),
		//который "достает" значения private-переменных класса.
		//Вызовите созданный метод, проверьте корректность.
		

		int x1 = r.GetAll("m_left");
		int x2 = r.GetAll("m_right");
		int y1= r.GetAll("m_top");
		int y2 = r.GetAll("m_bottom");

		cout << x1 <<" " <<x2<<" "<<y1<<" "<<y2 << endl;
		}
	
	
		//Задание 4.Передача экземпляра класса в качестве параметра
		//функции. Возвращение объекта класса по значению. Поставив
		//остановы в конструкторе копирования или выполняя фрагмент
		//по шагам, определите: в какой момент происходит обращение
		//к конструктору копирования.
		//Создайте глобальную функцию
		// Rect BoundingRect(Rect, Rect);
		//которая принимает два объекта класса Rect по значению и
		//возвращает объект класса Rect, который является прямоугольником,
		//в который вписаны заданные прямоугольники. Как происходит
		//передача параметров и возвращение объекта класса?

		//Замечание*: хорошо было бы учесть тот факт, что прямоугольник
		//может оказаться "ненормализованным", то есть m_left>m_right или/и
		//m_top>m_bottom
		numz(4);
		{
			

			Rect r1(1, 7, 8, 4), r2(2, 9, 8, 3), r3;
			cout << "Исходные данные: \nПервый прямоугольник: ";
			r1.print();
			cout << "Второй прямоугольник: ";
			r2.print();

			r3 = BoundingRect(r1, r2);
			cout << "\nИтоговое значение 1: ";
			r3.print();


			//Задание 4а. Передача объектов по ссылке.
			//Создайте глобальную функцию BoundingRect2, которая выполняет ту же
			//задачу, принимая параметры по ссылке
			//Вызываются ли конструкторы при передаче параметров?


			r3 = BoundingRect2(r1, r2);
			cout << "Итоговое значение 2: ";
			r3.print();
		}

	

	
		//Задание 5. Когда вызываются конструкторы и деструкторы.
		//Объявите и определите
		//явный деструктор класса. Поставьте остановы в
		//конструкторе (конструкторах) и деструкторе. Определите: когда для
		//каждого из объектов вызывается конструктор, а когда - деструктор?
		numz(5);
		cout << endl;
		cout << "Задание без вывода, в комментариях прописал время жизни переменных." << endl;
		cout << endl;
		{
			Rect r1; //вызывается конструктор
			Rect*	pR = new Rect(1,2,1,2); //вызывается конструктор
			{
				Rect r2(r1); //вызывается конструктор копирования
				Rect arRect[2]; //вызывается конструктор дважды
				for(int i=0; i<3; i++)
				{
					static Rect r3 (i,i,i,i) ; //вызывается конструктор 1 раз (деструктор по завершению main)
					Rect r4(*pR); //вызывается конструктор копирования каждую итерацию
					Rect r5(i,i,i,i); //вызывается конструктор каждую итерацию
				}//вызываются деструкторы каждую итерацию для r5 и r4
			}//вызывается деструктор дважды для arRect и один раз для r2 
			delete pR; //память освобождается
			
		}//вызываются конструкторы для pR и r1
	
	
		//Задание 6.Конструктор + деструктор = функциональное
		// замыкание. Класс MyString
		// Посредством конструктора (конструкторов) и деструктора обеспечьте
		//корректные инициализацию и деактивацию объекта
		//C помощью остановов определите когда происходит
		//захват и освобождение памяти для строки-члена класса
		numz(6);
		{
			MyString	str("It's my string!");
			//Создайте метод GetString(), который обеспечит доступ к хранящейся строке.
			//С помощью cout и метода GetString() распечатайте строку объекта str
			//Замечание: подумайте, как следует корректно реализовать метод GetString().
			string s = str.GetString();
			cout << s << endl;
			//...
		}
		
	
	
		//6a. Раскомментируйте следующий фрагмент. Подумайте - какие
		//неприятности Вас ожидают. Попробуйте исправить положение (как?)
			{
				MyString str1("The first string!");
				MyString str2 = str1;
				string a = str2.GetString();
				cout << a << endl;
				string b = str1.GetString();
				cout << b << endl;
			}

		//6б. Реализуйте метод SetNewString, который будет заменять строку
		// на новую

			{
				MyString str3("Second string");
				str3.StrNewString("Third string");
				string c = str3.GetString();
				cout << c << endl;
			}




	

	numz(7);
	//Задание 7.  Решите с помощью классов следующую задачу:
	//даны две бочки известного объема. В одной бочке в начальный момент
	//времени содержится спирт (96%), в другой – вода.
	//Кружкой емкостью 1л переливаем итеративно содержимое из одной бочки
	//в другую следующим способом: на каждой итерации
	//зачерпнули из первой бочки -> вылили во вторую
	//зачерпнули из второй бочки -> вылили в первую.
	//Требуется определить номер итерации, на которой концентрация спирта в
	//первой бочке станет меньше 50%.

	Bochka spirt(10, 96);
	//spirt.print();
	Bochka water(10, 0);
	//water.print();
	cout << "\nВходные данные: " << endl;
	cout << "\nБочка со спиртом:" << endl;
	spirt.print();
	cout << "\nБочка с водой:" << endl;
	water.print();

	int cnt = 0;
	while ( spirt.GetP() > 50 ) {

		spirt.Pereliv(&water);
		water.Pereliv(&spirt);

		//Проверка:
		/*cout << "\nБочка со спиртом:" << endl;
		spirt.print();
		cout << "\nБочка с водой:" << endl;
		water.print();*/
		cnt += 1;
	}
	cout << "\nОтвет и конечные данные: " << endl;
	cout << "\nСчётчик: " << cnt << endl;
	cout << "\nБочка со спиртом:" << endl;
	spirt.print();
	cout << "\nБочка с водой:" << endl;
	water.print();
	return 0;
}//вызывается деструктор для r3